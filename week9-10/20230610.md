# 【日報：6/10 ~ 1１ (土 ~ 日)】
## 本日の目標（TODO目標/できるようになりたいこと）
- 『コードレビューで学ぶ Ruby on Rails』を読了
## 学習時間（Hour）
- 4h ＋ 6h
## 目標振り返り（TODO進捗/できるようになりたいこと振り返り）
- 読了
## 詰まっていること（実現したいこと/現状/行ったこと/仮説）
- 特になし
## 学んだこと（新しい気付き、学び）
- 4 Test
  - 4.1 describe/context/it でテスト対象を表現する
    - describe：「テスト対象」を記述する
      - クラス名
      - メソッド名( インスタンスメソッド：`ClassName#method_name`、クラスメソッド：`ClassName.method_name` )
      - 機能名
    - context：「状況や条件」を記述する
      - 「〜の場合」
    - it：「期待する動作・結果」を記述する
      - 「〜であること(状態)」「〜できること(動作)」
  - 4.2 テストコード単体で期待値の根拠を示す
    - FactoryBot で指定したデフォルト値をそのまま期待値にすると可読性が下がるため、オブジェクトを作成する段階で明示的に期待値の根拠を示すのが良い。そうすることで複数ファイルを開く必要がなくなる。
  - 4.3 システムテストでは操作後の結果まで確認しよう
    - system spec では、ユーザーによる基本的な操作が実現可能であることと、操作後の画面の変化を確認する。
      - フラッシュメッセージ、画面の表示：`expect(page).to have_content 'タスクが正常に作成されました'`
      - パス：create 後に正しい show 画面に遷移しているか
        ```
        # 現在のページのURLが、引数( task_path(task) )から生成したURLと同じであること
        task = Task.last
        expect(page).to have_current_path task_path(task)
        ```
      - データベースの確認は、
        - レコードの数の増減：`expect do ~ end.to change(ModelName :count).by(1)`
        - レコードの属性：`expect(ModelName).to have_attributes(name: 'user_name')`
    - system spec では網羅性を求めずに、「基本的な操作が実現可能であること(機能)」「コアとなるユースケースに欠陥が無いこと(ケース)」を中心に確認し、網羅性は model spec で担保しよう。
  - 4.4 デザインに依存しないテストを書こう
    - テスト専用の属性として data-test-id を使って要素を指定することで、CSSクラスへの依存がなくなり、デザインを変更してもテストが壊れなくなる。
      - html.erb：data-test-id 属性に task の dom_id を設定する
        ```ruby
        data: { test_id: dom_id(task) }
        # 上記コードは次のようなHTMLを生成する => data-test-id="task_1"
        ```
      - tasks_spec.rb：デザインに依存せずに要素を指定できる
        ```ruby
        find("[data-test-id='#{dom_id(task)}']").click
        ```
      - さらに、Capybara の CSS selector を拡張することで、シンプルに記述することもできる
        - spec/support/capybara.rb
          ```ruby
          # Capybaraにカスタムセレクタ( :test_id )を追加する
          Capybara.add_selector(:test_id) do
            css { |id| "[data-test-id='#{id}']" }
          end
          ```
        - spec/systems/tasks_spec.rb
          ```ruby
          # 作成したselector をしようして要素を指定できる
          find(:test_id, dom_id(task)).click
          ```
  - 4.5 入力値や期待値はベタ書きにする
    - テストの可読性や妥当性のために、入力値や期待値には変数を用いずベタ書きする
      - 入力値：fill_in ~, with: (ベタ書き)
      - 期待値：expect(page).to have_content "(ベタ書き)"
  - 4.6 factory_bot の trait を使って書く負担を減らす
    - trait 機能を使うことで、テストで頻出する定義を簡潔に記述することができる。テストコードは簡潔に、必要のない情報を極力見せないことで、読み書きする際の負担を減らす。
      - 頻出する定義は trait を使う。記述が短くなるし、理解しやすくなる。
      - デフォルトでは関連レコードは作成しないようにし、trait を用いて関連レコードの作成を明記する方がわかりやすい。
        ```ruby
        # :with_user で関連を用いていることを明示する
        FactoryBot.create(:task, :with_user)
        ```
  - 4.7「されないこと」だけの検証には注意が必要
    - 「表示されないこと」を検証する際は「表示されること」も併せて確認する。
      ```ruby
      # 非表示に設定されている'タスク２'が、一覧画面に表示されていないことを確認する場合
      expect(page).to have_content('タスク１')
      expect(page).to_not have_content('タスク２')
      ```
    - 条件を反転させた結果テストに失敗することを確認することで、タイポなどのミスに気付きやすくなる。
  - 4.8 Strong Parameter の設定漏れを検知する
    - 以下のような設定を行うと、Strong Parametersで許可されていないパラメータが送信された場合に例外を発生させることができ、permit の設定漏れを検知することができる。
      config/environments/test.rb, config/environments/development.rb
      ```ruby
      config.action_controller.action_on_unpermitted_parameters = :raise
      ```
  - 4.9 テストコードを準備(Arrange)、実行(Act)、検証(Assert)で構造化しよう
    - テストコードは「読みやすく、分かりやすいこと」が大切。
    - describe/context/it で適切に場合分けし、DRYにこだわらず、ベタ書きして読みやすいコードを書く。
  - 4.10 sleep は使ったら負け？
    - `expect(page).to have_content '登録されました'` で殆どの sleep は回避できる。
    - `expct(page)`なら capybara が要素の出現まで、デフォルトで２秒まで待機するようになっている。
  - 4.11 効率よくテストを書く
    - システムテストで基本的な動作をテストして、ユニットテストで細かいロジックのテストをすると効率が良いです。
- 5 その他
  - 5.1 環境間の差異を意識する
    - 各環境の差異が大きいと環境依存の不具合の原因になる。各環境のデータベースなどシステム構成はできるだけ揃えて、コード上でも環境変数や credentials で違いを吸収する。
  - 5.2 gem バージョンを固定しない
    - Gemfile の gem のバージョン固定は避ける。
    - 代わりにテストを書いて、常に Bundle install できる状況を作る。
    - どうしてもバージョンを固定したい場合は Gemfile にコメントを残す。
    - Rails のように、バージョンを固定すべきものもあるので、それらは定期的に手動でバージョンアップする。
  - 5.3 Enumerable を活用する
    - Ruby では、配列やコレクションを扱う際、Enumerable モジュールのメソッドを活用することで、より簡潔で可読性の高いコードが書ける。
      - map： ブロックの処理を適用し、その結果からなる新しい配列を作成する。
      - select： ブロックの処理を適用し、その評価結果が真であった要素からなる新しい配列を作成する。
      - reduce： ブロックの処理を適用し、一つの値に畳み込みます。例えば、配列の全要素の和を求めることなどができる。
  - 5.4 YAGNI( You Ain't Gonna Need It(それは必要にならない) )
    - 将来的な拡張性を過剰に考慮してコードを書くことは避け、必要である機能を実装する。
  - 5.5 命名について
    - クラス：名詞( User, Player など )
    - メソッド
      - 副作用なし：名詞( full_name など ) ※ 真偽値を返すものには末尾に「?」をつける
      - 副作用あり：動詞( follow(author) など ) ※ 例外を投げる、または破壊的なメソッドには「!」をつける
      - ※ 副作用があるとは：DB、グローバルな変数、ファイルへの書き込みなどを伴う処理
    - 変数
      - Array：名詞。繰り返し処理が必要なものは複数形。
      - Hash：名詞。xxx_map, xxx_params と命名することが多い。なるべく限定されたスコープで使用し、逆にスコープが広く変数名が長い場合は Struct や Data を使用する。
    - Model：名詞の単数形
    - Controller：名詞の複数形 ※ pluralize メソッドの方が間違っていることもあるので、その際は設定ファイルを修正しよう。
    - View：対応するコントローラのアクション名。パーシャルの場合は _ を付ける。
    - Helper：名詞の単数形。View上では名前空間がグローバルになるため、他のメソッドとは被らないようにモジュール名を接頭辞に付ける。
    - Mailer：名詞。メールの受信者を基準に命名する。
    - Spec：model spec はモデル名と同じ。system spec はコントローラのファイル構造と合わせる。
      - describe：クラス名、メソッド名
      - context :「〜の場合」
      - it, example :「〜であること(状態)」「〜できること(動作)」
    - DB テーブル：名詞の複数形
    - DB カラム：名詞
      - date/datetime：date型のカラムは「動詞の過去形 + on」、datetime型は「動詞の過去形 + at」
      - boolean：形容詞か受動態。例えば approve ではなく approvable?(承認可能かどうか) や、approved?(承認済みかどうか) のように表現する。
  - 5.6 禁止リストよりも許可リストを優先的に使おう
    - 許可リスト方式の場合、リストへの追加を忘れたとしても、情報漏洩やデータ改竄などの大きな問題にはなりにくいため、禁止リスト方式より安全。
  - 5.7 コメントには言い訳を書く
    - 読むだけで動作がわかるような読みやすいコードを書く。
    - コメントにはコードで表現できなかったことを書く。
    - アノテーションをつける：NOTE, TODO, FIXME など。`rails notes`コマンドでアノテーションのついたコメントを抽出できる。

## 感想（一日の感想、雑談）
- 生活リズムの悪化がひどい。雨、低気圧、体調不良などで焦りばかりが先行する。
## 明日の目標（TODO目標/できるようになりたいこと）
- 『Stripeを使ってECサイトを作ろう（Rails7対応）』を学習する
